<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Accel Display</title>
  <style>
    /* --- CORE STYLES --- */
    body, html { margin: 0; height: 100vh; overflow: hidden; background: #000; font-family: system-ui, sans-serif; color: white; }
    #tilesContainer { position: relative; width: 100%; height: 100%; }
    
    .tile { 
      position: absolute; 
      box-sizing: border-box; 
      overflow: hidden; 
      user-select: none; /* Prevents text highlighting while dragging */
    }
    
    /* Transition only applied in Display Mode to prevent lag in Edit Mode */
    body:not(.editing) .tile { transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out; }

    /* Content styling */
    .tile img, .tile video, .tile iframe { width: 100%; height: 100%; object-fit: cover; display: block; pointer-events: none; }
    .tile iframe { pointer-events: auto; } /* Allow interaction in view mode */
    body.editing .tile iframe { pointer-events: none; } /* Block iframe interaction in edit mode so we can drag it */

    /* Utilities */
    .marquee { white-space: nowrap; display: inline-block; animation: marquee 15s linear infinite; }
    @keyframes marquee { 0% { transform: translateX(100%); } 100% { transform: translateX(-100%); } }

    /* Slide Logic */
    .slide-hidden { opacity: 0; visibility: hidden; pointer-events: none; z-index: -1; }
    .slide-active { opacity: 1; visibility: visible; z-index: 1; }

    /* --- EDITOR STYLES --- */
    body.editing #tilesContainer {
      /* 5% Grid Background for alignment */
      background-image:
        linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
      background-size: 5% 5%;
    }

    body.editing .tile { 
      border: 1px dashed rgba(255, 255, 255, 0.3); 
      cursor: grab; 
    }
    body.editing .tile:active { cursor: grabbing; }
    
    body.editing .tile.selected { 
      border: 2px solid #3b82f6; 
      z-index: 9999 !important; /* Bring selected to front */
      box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
    }

    /* Resize Handles (4 corners) */
    .resize-handle {
      display: none; position: absolute; width: 12px; height: 12px;
      background: #3b82f6; border: 1px solid #fff; z-index: 10000;
    }
    body.editing .tile.selected .resize-handle { display: block; }
    .rh-tl { top: -6px; left: -6px; cursor: nw-resize; }
    .rh-tr { top: -6px; right: -6px; cursor: ne-resize; }
    .rh-bl { bottom: -6px; left: -6px; cursor: sw-resize; }
    .rh-br { bottom: -6px; right: -6px; cursor: se-resize; }

    /* Secret Button */
    #secretBtn {
      position: fixed; bottom: 0; right: 0; width: 60px; height: 60px;
      z-index: 99999; cursor: default;
    }

    /* ADMIN PANEL */
    #adminPanel {
      position: fixed; top: 0; right: -360px; width: 340px; height: 100%;
      background: #1a1a1a; border-left: 1px solid #333; 
      transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100000; display: flex; flex-direction: column; padding: 15px; 
      box-sizing: border-box; box-shadow: -5px 0 15px rgba(0,0,0,0.8);
    }
    body.editing #adminPanel { right: 0; }
    body.editing #adminPanel.collapsed { right: -300px; opacity: 0.8; }

    .panel-header { 
      font-weight: bold; margin-bottom: 15px; border-bottom: 1px solid #333; 
      padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center; 
    }

    .form-group { margin-bottom: 10px; }
    .form-group label { display: block; font-size: 11px; color: #aaa; margin-bottom: 4px; }
    .form-group input, .form-group select, .form-group textarea { 
      width: 100%; padding: 6px; background: #222; border: 1px solid #444; 
      color: white; border-radius: 4px; box-sizing: border-box;
    }
    .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
      border-color: #3b82f6; outline: none;
    }
    .row { display: flex; gap: 10px; }
    
    .btn { width: 100%; padding: 10px; margin-top: 5px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; color: white; }
    .btn-save { background: #10b981; }
    .btn-add { background: #3b82f6; }
    .btn-del { background: #ef4444; }
    
    /* Export Modal */
    #exportModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 600px; background: #222; border: 1px solid #444; z-index: 200000; padding: 20px;
      box-shadow: 0 0 50px rgba(0,0,0,0.9);
    }
    #exportData { 
      width: 100%; height: 300px; background: #111; color: #0f0; border: 1px solid #333;
      font-family: monospace; font-size: 11px; white-space: pre; overflow: auto; 
    }
    #loadingOverlay {
        position:fixed; top:0; left:0; width:100%; height:100%; background:black; color:white;
        display:flex; align-items:center; justify-content:center; z-index:9999; font-size:24px;
        transition: opacity 0.5s; pointer-events:none; opacity:1;
    }
  </style>

  <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
</head>
<body>

  <div id="loadingOverlay">Loading Screen...</div>
  <div id="tilesContainer"></div>

  <div id="secretBtn" ondblclick="toggleEditMode()" title="Double Click or Ctrl+Shift+E to Edit"></div>

  <div id="adminPanel">
    <div class="panel-header">
      <button onclick="document.getElementById('adminPanel').classList.toggle('collapsed')" style="background:none; border:none; color:white; cursor:pointer;">➜</button>
      <span>EDITOR</span>
      <button onclick="toggleEditMode()" style="background:#ef4444; border:none; color:white; padding:2px 6px; border-radius:4px;">EXIT</button>
    </div>

    <div style="background:#333; padding:10px; border-radius:4px; margin-bottom:15px;">
      <div class="form-group" style="margin-bottom:0;">
        <label style="color:white; font-weight:bold;">Editing Slide ID:</label>
        <div style="display:flex; gap:5px;">
            <button class="btn" style="margin:0; width:30px;" onclick="changeEditorSlide(-1)">◀</button>
            <input type="number" id="globalSlideId" value="1" style="text-align:center;" readonly>
            <button class="btn" style="margin:0; width:30px;" onclick="changeEditorSlide(1)">▶</button>
        </div>
      </div>
      <div style="margin-top:5px;">
         <label><input type="checkbox" id="snapGrid"> Snap to 5% Grid</label>
      </div>
    </div>

    <div id="tileForm" style="opacity:0.5; pointer-events:none;">
      <div class="row">
         <div class="form-group"><label>Screen ID</label><input type="number" id="inp-screenId" onchange="updateActiveTile('screenId', this.value)"></div>
         <div class="form-group"><label>Slide ID</label><input type="number" id="inp-slideId" onchange="updateActiveTile('slideId', this.value)"></div>
      </div>

      <div class="form-group">
        <label>Type</label>
        <select id="inp-type" onchange="updateActiveTile('type', this.value)">
            <optgroup label="Basic"><option value="text">Text</option><option value="image">Image</option><option value="video">Video</option><option value="iframe">Iframe</option></optgroup>
            <optgroup label="Data"><option value="clock">Clock</option><option value="weather_detailed">Weather</option><option value="stock">Stock</option><option value="crypto">Crypto</option><option value="rss">RSS</option></optgroup>
            <optgroup label="Media"><option value="youtube">YouTube</option><option value="marquee">Marquee</option><option value="map">Map</option><option value="qrcode">QR Code</option></optgroup>
            <optgroup label="Shapes"><option value="shape">Shape</option><option value="gradient">Gradient</option></optgroup>
        </select>
      </div>
      <div class="form-group"><label>Content</label><textarea id="inp-content" rows="3" oninput="updateActiveTile('content', this.value)"></textarea></div>

      <div class="row">
        <div class="form-group"><label>X (%)</label><input type="number" step="0.1" id="inp-x" onchange="updateActiveTile('x', this.value + '%')"></div>
        <div class="form-group"><label>Y (%)</label><input type="number" step="0.1" id="inp-y" onchange="updateActiveTile('y', this.value + '%')"></div>
      </div>
      <div class="row">
        <div class="form-group"><label>W (%)</label><input type="number" step="0.1" id="inp-width" onchange="updateActiveTile('width', this.value + '%')"></div>
        <div class="form-group"><label>H (%)</label><input type="number" step="0.1" id="inp-height" onchange="updateActiveTile('height', this.value + '%')"></div>
      </div>
      
      <div class="row">
        <div class="form-group"><label>Bg Color</label><input type="color" id="inp-bgColor" style="height:30px; padding:0;" onchange="updateActiveTile('bgColor', this.value)"></div>
        <div class="form-group"><label>Text Color</label><input type="color" id="inp-textColor" style="height:30px; padding:0;" onchange="updateActiveTile('textColor', this.value)"></div>
      </div>
      <div class="row">
        <div class="form-group"><label>Font Size</label><input id="inp-fontSize" onchange="updateActiveTile('fontSize', this.value)"></div>
        <div class="form-group"><label>Z-Index</label><input type="number" id="inp-zIndex" onchange="updateActiveTile('zIndex', this.value)"></div>
      </div>

      <button class="btn btn-del" onclick="deleteActiveTile()">Delete Selected</button>
    </div>

    <hr style="border-color:#333; margin: 15px 0; width:100%;">
    <button class="btn btn-add" onclick="addNewTile()">+ Add Tile to Slide</button>
    <button class="btn btn-save" onclick="exportData()">EXPORT DATA</button>
    <div style="font-size:10px; color:#888; text-align:center; margin-top:5px;">Copy -> Paste into Google Sheets (A2)</div>
  </div>

  <div id="exportModal">
    <h3 style="margin-top:0; color:#10b981;">Export Data for Google Sheets</h3>
    <p style="font-size:12px; color:#ccc">
        1. Click the box below.<br>
        2. Select All (Ctrl+A) and Copy (Ctrl+C).<br>
        3. Go to your Google Sheet.<br>
        4. Click Cell <b>A2</b> and Paste (Ctrl+V).
    </p>
    <textarea id="exportData" readonly onclick="this.select()"></textarea>
    <button class="btn btn-save" onclick="document.getElementById('exportModal').style.display='none'">Close</button>
  </div>

<script>
  // --- CONFIG ---
  const API_URL = "https://script.google.com/macros/s/AKfycbwfvm03NIpoxNeTr9sfB75RlHzispd9oz3okFHAMmxPpuwLu672AeltcwgYb7Gl_ZHedQ/exec"; 
  const SLIDE_DURATION_MS = 15000;
  
  // --- STATE ---
  let tiles = [];
  let isEditing = false;
  let activeTileId = null; // using array index
  let slideTimer;
  let refreshTimer;
  let currentPlaySlide = 1;
  let currentEditSlide = 1;
  let maxSlide = 1;
  
  const urlParams = new URLSearchParams(window.location.search);
  const SCREEN_ID = parseInt(urlParams.get('screenId')) || 1;

  // --- INITIALIZATION ---
  async function loadData() {
    try {
      document.getElementById('loadingOverlay').style.opacity = '1';
      const res = await fetch(`${API_URL}?screenId=${SCREEN_ID}&t=${Date.now()}`);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      
      // Data Normalization
      tiles = data.map(t => ({
        ...t,
        screenId: parseInt(t.screenId) || 1,
        slideId: parseInt(t.slideId) || 1,
        visible: t.visible !== false,
        x: normalizeUnit(t.x),
        y: normalizeUnit(t.y),
        width: normalizeUnit(t.width),
        height: normalizeUnit(t.height),
        zIndex: parseInt(t.zIndex) || 1
      }));

      // Calc max slide
      maxSlide = tiles.reduce((max, t) => Math.max(max, t.slideId), 1);
      
      renderBoard();
      startSlideshow();
      
      document.getElementById('loadingOverlay').style.opacity = '0';
    } catch (e) {
      console.error(e);
      document.getElementById('loadingOverlay').textContent = "Error Loading Data";
    }
  }

  function normalizeUnit(val) {
    if (!val) return "0%";
    // If it's a raw number or string number, assume % for compatibility
    if (!isNaN(val)) return val + "%"; 
    if (val.toString().includes("px")) {
        // Convert pixels to approximation if user messed up manual entry
        return "10%"; 
    }
    return val; 
  }

  // --- RENDERING ---
  function renderBoard() {
    const container = document.getElementById("tilesContainer");
    container.innerHTML = ""; // Clear board
    
    // Determine which slide to show
    const visibleSlide = isEditing ? currentEditSlide : currentPlaySlide;
    
    tiles.forEach((t, index) => {
      // In Play Mode: Filter by visible slide. In Edit Mode: Filter by Edit Slide
      if (!isEditing && t.slideId !== visibleSlide) return;
      if (isEditing && t.slideId !== currentEditSlide) return;
      if (!t.visible && !isEditing) return;

      const el = document.createElement("div");
      el.className = "tile";
      el.dataset.index = index;
      
      // Apply geometry
      el.style.left = t.x; 
      el.style.top = t.y;
      el.style.width = t.width; 
      el.style.height = t.height;
      el.style.zIndex = t.zIndex;

      // Apply styling
      el.style.backgroundColor = t.bgColor || "rgba(0,0,0,0.5)";
      el.style.color = t.textColor || "white";
      el.style.fontSize = t.fontSize || "24px";
      el.style.padding = t.padding || "10px";
      el.style.borderRadius = t.radius || "0px";
      el.style.textAlign = t.align || "center";
      el.style.display = "flex";
      el.style.alignItems = "center";
      el.style.justifyContent = "center";

      // Render Content
      el.innerHTML = getTileContent(t);

      // Editor Handles
      if (isEditing) {
        el.onmousedown = (e) => handleDragStart(e, index, el);
        el.ontouchstart = (e) => handleDragStart(e, index, el); // Touch support
        
        // Add 4 corner handles
        ['tl','tr','bl','br'].forEach(pos => {
            const h = document.createElement('div');
            h.className = `resize-handle rh-${pos}`;
            h.onmousedown = (e) => handleResizeStart(e, index, el, pos);
            h.ontouchstart = (e) => handleResizeStart(e, index, el, pos);
            el.appendChild(h);
        });
      }
      
      container.appendChild(el);
    });

    // Start independent clocks
    startClocks();
  }

  function getTileContent(t) {
      if(!t.content) return `<span style="font-size:10px; opacity:0.5">${t.type}</span>`;
      
      switch(t.type) {
          case 'image': return `<img src="${t.content}">`;
          case 'video': return isEditing ? `[Video]` : `<video src="${t.content}" autoplay loop muted playsinline></video>`;
          case 'text': return t.content.replace(/\n/g, '<br>');
          case 'clock': return `<div class="live-clock">${new Date().toLocaleTimeString()}</div>`;
          case 'iframe': return isEditing ? `[Iframe]` : `<iframe src="${t.content}" style="border:0; width:100%; height:100%"></iframe>`;
          case 'marquee': return `<div class="marquee">${t.content}</div>`;
          case 'html': return t.content;
          default: return t.content;
      }
  }

  function startClocks() {
      // Update clocks independently of re-renders
      const clocks = document.querySelectorAll('.live-clock');
      if(clocks.length > 0) {
          if(window.clockInterval) clearInterval(window.clockInterval);
          window.clockInterval = setInterval(() => {
              document.querySelectorAll('.live-clock').forEach(c => c.innerText = new Date().toLocaleTimeString());
          }, 1000);
      }
  }

  // --- SLIDESHOW LOGIC ---
  function startSlideshow() {
    if (slideTimer) clearInterval(slideTimer);
    slideTimer = setInterval(() => {
      if (isEditing) return;
      currentPlaySlide++;
      if (currentPlaySlide > maxSlide) currentPlaySlide = 1;
      renderBoard(); // Simple re-render for slide change
    }, SLIDE_DURATION_MS);
  }

  // --- EDITOR LOGIC ---
  function toggleEditMode() {
    isEditing = !isEditing;
    document.body.classList.toggle("editing");
    
    if (isEditing) {
      // Stop auto-rotation and refresh
      clearInterval(slideTimer);
      clearInterval(refreshTimer);
      
      // Sync Editor slide to current play slide
      currentEditSlide = currentPlaySlide;
      document.getElementById('globalSlideId').value = currentEditSlide;
      document.getElementById('adminPanel').classList.remove('collapsed');
      
      renderBoard();
    } else {
      // Resume
      activeTileId = null;
      loadData(); // Reload from server to reset changes or confirm save
      refreshTimer = setInterval(loadData, 60000);
      startSlideshow();
    }
  }

  function changeEditorSlide(dir) {
      currentEditSlide += dir;
      if(currentEditSlide < 1) currentEditSlide = 1;
      document.getElementById('globalSlideId').value = currentEditSlide;
      activeTileId = null;
      updateFormState();
      renderBoard();
  }

  function activateTile(index) {
    activeTileId = index;
    document.querySelectorAll('.tile').forEach(el => el.classList.remove('selected'));
    const el = document.querySelector(`.tile[data-index='${index}']`);
    if(el) el.classList.add('selected');
    
    // Populate Form
    const t = tiles[index];
    const map = {
        'type': t.type, 'content': t.content, 
        'x': parseFloat(t.x), 'y': parseFloat(t.y), 
        'width': parseFloat(t.width), 'height': parseFloat(t.height),
        'bgColor': t.bgColor, 'textColor': t.textColor,
        'fontSize': t.fontSize, 'zIndex': t.zIndex,
        'screenId': t.screenId, 'slideId': t.slideId
    };
    
    for (const [key, val] of Object.entries(map)) {
        const inp = document.getElementById(`inp-${key}`);
        if(inp) inp.value = val || '';
    }
    updateFormState();
  }
  
  function updateFormState() {
      const form = document.getElementById('tileForm');
      form.style.opacity = activeTileId !== null ? "1" : "0.5";
      form.style.pointerEvents = activeTileId !== null ? "auto" : "none";
  }

  function updateActiveTile(key, value) {
      if(activeTileId === null) return;
      tiles[activeTileId][key] = value;
      
      // Update DOM directly for performance (no full re-render)
      const el = document.querySelector(`.tile[data-index='${activeTileId}']`);
      if(el) {
          if(['x','y','width','height','zIndex','bgColor','color','fontSize'].includes(key)) {
              if(key === 'x') el.style.left = value;
              if(key === 'y') el.style.top = value;
              if(key === 'width') el.style.width = value;
              if(key === 'height') el.style.height = value;
              if(key === 'bgColor') el.style.backgroundColor = value;
          } else {
              // Content/Type changes require re-render
              renderBoard();
              // Re-select
              setTimeout(() => activateTile(activeTileId), 0);
          }
      }
  }

  function addNewTile() {
      tiles.push({
          screenId: SCREEN_ID,
          slideId: currentEditSlide,
          type: 'text',
          content: 'New Tile',
          x: '35%', y: '35%', width: '30%', height: '20%',
          bgColor: '#3b82f6',
          visible: true, zIndex: 10
      });
      renderBoard();
      activateTile(tiles.length - 1);
  }

  function deleteActiveTile() {
      if(activeTileId !== null && confirm("Delete this tile?")) {
          tiles.splice(activeTileId, 1);
          activeTileId = null;
          renderBoard();
          updateFormState();
      }
  }

  // --- DRAG & DROP (Unified Mouse/Touch) ---
  function handleDragStart(e, index, el) {
    e.stopPropagation();
    // Determine input type
    const isTouch = e.type === 'touchstart';
    const pageX = isTouch ? e.touches[0].pageX : e.pageX;
    const pageY = isTouch ? e.touches[0].pageY : e.pageY;
    
    activateTile(index);
    
    const startLeft = el.offsetLeft;
    const startTop = el.offsetTop;
    const containerW = el.parentElement.clientWidth;
    const containerH = el.parentElement.clientHeight;
    
    const snap = document.getElementById('snapGrid').checked;

    function onMove(ev) {
        ev.preventDefault();
        const curX = isTouch ? ev.touches[0].pageX : ev.pageX;
        const curY = isTouch ? ev.touches[0].pageY : ev.pageY;
        
        let newX = startLeft + (curX - pageX);
        let newY = startTop + (curY - pageY);
        
        // Snap Logic (5% increments)
        if (snap) {
            const stepX = containerW * 0.05;
            const stepY = containerH * 0.05;
            newX = Math.round(newX / stepX) * stepX;
            newY = Math.round(newY / stepY) * stepY;
        }

        el.style.left = newX + 'px';
        el.style.top = newY + 'px';
        
        // Update inputs live (converted to %)
        document.getElementById('inp-x').value = ((newX/containerW)*100).toFixed(2);
        document.getElementById('inp-y').value = ((newY/containerH)*100).toFixed(2);
    }

    function onEnd() {
        if(isTouch) {
            document.removeEventListener('touchmove', onMove);
            document.removeEventListener('touchend', onEnd);
        } else {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onEnd);
        }
        
        // Save Final State
        tiles[index].x = ((el.offsetLeft / containerW) * 100).toFixed(2) + "%";
        tiles[index].y = ((el.offsetTop / containerH) * 100).toFixed(2) + "%";
    }

    if(isTouch) {
        document.addEventListener('touchmove', onMove, {passive: false});
        document.addEventListener('touchend', onEnd);
    } else {
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onEnd);
    }
  }

  // --- RESIZE LOGIC (Unified) ---
  function handleResizeStart(e, index, el, corner) {
    e.stopPropagation();
    const isTouch = e.type === 'touchstart';
    const pageX = isTouch ? e.touches[0].pageX : e.pageX;
    const pageY = isTouch ? e.touches[0].pageY : e.pageY;

    const startW = el.offsetWidth;
    const startH = el.offsetHeight;
    const startX = el.offsetLeft;
    const startY = el.offsetTop;
    const containerW = el.parentElement.clientWidth;
    const containerH = el.parentElement.clientHeight;
    
    const snap = document.getElementById('snapGrid').checked;

    function onMove(ev) {
        ev.preventDefault();
        const curX = isTouch ? ev.touches[0].pageX : ev.pageX;
        const curY = isTouch ? ev.touches[0].pageY : ev.pageY;
        const dx = curX - pageX;
        const dy = curY - pageY;

        let newW = startW, newH = startH, newX = startX, newY = startY;

        // Calculate based on corner
        if (corner.includes('r')) newW = startW + dx;
        if (corner.includes('l')) { newW = startW - dx; newX = startX + dx; }
        if (corner.includes('b')) newH = startH + dy;
        if (corner.includes('t')) { newH = startH - dy; newY = startY + dy; }
        
        // Snap Dimensions
        if(snap) {
             const stepX = containerW * 0.05;
             const stepY = containerH * 0.05;
             newW = Math.round(newW / stepX) * stepX;
             newH = Math.round(newH / stepY) * stepY;
             // Note: Snapping position while resizing top/left is complex, omitted for stability
        }

        // Apply Min Size
        if (newW > 20) { el.style.width = newW + 'px'; el.style.left = newX + 'px'; }
        if (newH > 20) { el.style.height = newH + 'px'; el.style.top = newY + 'px'; }
        
        // Update Inputs
        document.getElementById('inp-width').value = ((el.offsetWidth/containerW)*100).toFixed(2);
        document.getElementById('inp-height').value = ((el.offsetHeight/containerH)*100).toFixed(2);
    }

    function onEnd() {
        if(isTouch) {
            document.removeEventListener('touchmove', onMove);
            document.removeEventListener('touchend', onEnd);
        } else {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onEnd);
        }
        
        tiles[index].width = ((el.offsetWidth / containerW) * 100).toFixed(2) + "%";
        tiles[index].height = ((el.offsetHeight / containerH) * 100).toFixed(2) + "%";
        tiles[index].x = ((el.offsetLeft / containerW) * 100).toFixed(2) + "%";
        tiles[index].y = ((el.offsetTop / containerH) * 100).toFixed(2) + "%";
    }

    if(isTouch) {
        document.addEventListener('touchmove', onMove, {passive: false});
        document.addEventListener('touchend', onEnd);
    } else {
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onEnd);
    }
  }

  // --- EXPORT ---
  function exportData() {
      // EXACT COLUMN MATCHING CODE.GS
      const headers = [
        "visible", "screenId", "slideId", "type", "content", "videoMode",
        "x", "y", "width", "height", 
        "bgColor", "textColor", "fontFamily", "fontSize", "bold", "align", 
        "padding", "radius", "shadow", 
        "opacity", "rotate", "zIndex"
      ];
      
      const tsv = tiles.map(t => {
          return headers.map(h => {
              let val = t[h];
              if (val === undefined || val === null) return "";
              if (h === 'visible') return val ? "TRUE" : "FALSE";
              return val.toString().replace(/(\r\n|\n|\r)/gm, " "); // Clean newlines
          }).join("\t");
      }).join("\n");
      
      document.getElementById('exportData').value = tsv;
      document.getElementById('exportModal').style.display = 'block';
  }

  // --- KEYBOARD SHORTCUT ---
  document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'E') {
          e.preventDefault();
          toggleEditMode();
      }
  });

  // START
  loadData();
  refreshTimer = setInterval(loadData, 60000);

</script>
</body>
</html>
